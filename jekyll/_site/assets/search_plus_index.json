{"/jekyll/update/2023-09-11-welcome-to-jekyll.html": {
    "title": "Welcome to Jekyll!",
    "keywords": "jekyll update",
    "url": "/jekyll/update/2023-09-11-welcome-to-jekyll.html",
    "body": "You’ll find this post in your _posts directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run jekyll serve, which launches a web server and auto-regenerates your site when a file is updated. To add new posts, simply add a file in the _posts directory that follows the convention YYYY-MM-DD-name-of-post.ext and includes the necessary front matter. Take a look at the source for this post to get an idea about how it works. Jekyll also offers powerful support for code snippets: def print_hi(name) puts \"Hi, #{name}\" end print_hi('Tom') #=&gt; prints 'Hi, Tom' to STDOUT. Check out the Jekyll docs for more info on how to get the most out of Jekyll. File all bugs/feature requests at Jekyll’s GitHub repo. If you have questions, you can ask them on Jekyll Talk."
  },"/jekyll/update/2023-09-11-terraform.html": {
    "title": "Terraform",
    "keywords": "jekyll update",
    "url": "/jekyll/update/2023-09-11-terraform.html",
    "body": "Terrform info Locals Modules Count vs For_each Import vs Data Source Features Block Dynamic Blocks Override Terrform practice Install Terraform Conenct to Azure Azure Storage account Terraform commands Terraform code Access the VM Custom data Install remote SSH VSC extension to access the remote VM Data sources Outputs Variables Conditionals Terrform info References: https://youtube.com/playlist?list=PLnWpsLZNgHzVVslxs8Bwq19Ng0ff4XlFv Use the resources instead of variables to set a dependency on the creation of the resource. Terraforms treats all the divided .tf files as the same file. Locals To assign a name to an expression. Update the local to modify all instance of the expression. Helps with repeating values. Overuse can make code difficult to read. Modules Reusable code. Collection of resources. Accepts inputs, produces outputs. Modules are not a single instance of a resource. Modules is a collection of resources. Example: https://github.com/tsrob50/TerraformExamples/tree/main/ModuleExample Count vs For_each Count Use count if the instances of the resources are almost identical. Using the index to identify the different instances. For_each Multiple versions of similar versions. Uses areguments where the value is mapped to a set of strings. Map is a key value pair. Example: https://github.com/tsrob50/TerraformExamples/tree/main/VNetandBastionHost Import vs Data Source Import Imports infraestructure into Terraform management. Added to Terraform state and managed by Terraform going forward. Data Source Allows Terraform to define and use existing infraestructure. Not managed by Terraform. Data refreshed during Terraform Plan. Features Block Docs: https://registry.terraform.io/providers/hashicorp/azurerm/latest/docs/guides/features-block Dynamic Blocks Use for reosurce that have repetable nested blocks in their arguments. For example, servers can hhave multiple disks or NICs. A for_each loop is used to create multiple similar instances of an object such as a resource. A Dynamic Block uses a for_each loop to create multiple copies of a sub-resource nested inside a resource. Example: https://github.com/tsrob50/TerraformExamples/tree/main/DynamicNSG Override Avoid using. Useful for automation, it changes settings without modifying source files. Override file allows to override values in a Terraform deployment. It consists of a set of configurations that replace the values in existing .tf files. After all the .tf files are processed by Terraform, the override files are merged into the configuration. The merge replaces the values supplied by the configuration files. The name convention is important. The files are processed or merged in lexicographical order (alphabetic order). Override File Names: override.tf, override.tf.json test_override.tf, test_override.tf.json Terrform practice References: https://youtu.be/V53AHWun17s Install Terraform Donwload terraform.exe Move to “C:\\Program Files\\Terraform” Edit PATH environment variable terraform --version Conenct to Azure Azure CLI az login --use-device-code az account show az account set --subscription &lt;subscription_id&gt; az group list --query \"[?name=='mtc-resources']\" az network vnet subnet list -g rg-mock --vnet-name vnet-mock --query \"[?name=='subnet-mock']\" az vm image list --all --publisher=\"Canonical\" &gt; images.json az vm image list --all --publisher=\"Canonical\" --sku=\"22_04-lts-gen2\" Azure Storage account The Storage account name has to be unique. Do not create the Storage Account with Terraform. Consider that the Terraform state file in the Storage Account is not a stateless resource. Meaning it cannot be destroyed and recreat it as needed. There is state date in the Storage Account needed for deployments. The ACCOUNT_KEY is not needed if the deployment is don trough a Pipeline. $SUBCRIPTION_NAME=\"\" $RESOURCE_GROUP_NAME=\"rg-tfstate\" $STORAGE_ACCOUNT_NAME=\"tfstate01$(get-random)\" $CONTAINER_NAME=\"tfstate\" # Set subscription to be the current active subscription. az account show az account set --subscription &lt;subscription_id&gt; # Create resource group az group create --name $RESOURCE_GROUP_NAME --location eastus # Create storage account az storage account create --resource-group $RESOURCE_GROUP_NAME --name $STORAGE_ACCOUNT_NAME --sku Standard_LRS --encryption-services blob # Create blob container az storage container create --name $CONTAINER_NAME --account-name $STORAGE_ACCOUNT_NAME #Get the storage access key and store it as an environment variable $ACCOUNT_KEY=$(az storage account keys list --resource-group $RESOURCE_GROUP_NAME --account-name $STORAGE_ACCOUNT_NAME --query '[0].value' -o tsv) $env:ARM_ACCESS_KEY=$ACCOUNT_KEY Docs: https://developer.hashicorp.com/terraform/language/settings/backends/azurerm Terraform commands terraform init terraform frmt terraform plan terraform apply -help terraform apply terraform apply -auto-approve terraform apply -replace azurerm_linux_virtual_machine.mtc-vm terraform apply -refresh-only terraform state list terraform state show azurerm_resource_group.mtc-rg terraform state show azurerm_public_ip.mtc-nic terraform output terraform output public_ip_address terraform refresh terraform plan -destroy terraform apply -destroy terraform destroy Terraform code State file and its backup, do not modify unless is strictly necessary. More info: https://developer.hashicorp.com/terraform/language/state In mtc-test-rule.source_address_prefix, should be your public IP to connect to the Azure resources from local. Access the VM Create SSH key to access the VM: ssh-keygen -t rsa &gt; C:\\Users\\dumitrux/.ssh/privatekey ls ~/.ssh SSH into the VM terraform state show azurerm_public_ip.mtc-vm ssh -i ~/.ssh/privatekey adminuser@&lt;vm_ip&gt; lsb_release -a Custom data This will delete and create the VM ssh -i ~/.ssh/privatekey adminuser@&lt;vm_ip&gt; docker --version Install remote SSH VSC extension to access the remote VM Install VSC extension “Remote - SSH” Open Command Palette (Ctrl+Shift+P) Type “Remote-ssh: Add New SSH Host…” Type “ssh adminuser@\" Chose “~/.ssh/config” directory Open config file Create “windows-ssh-script.tpl” and “linux-ssh-script.tpl” Add the “provisioner” attribute in the “azurerm_linux_virtual_machine” Redeploy all terraform apply -replace azurerm_linux_virtual_machine.mtc-vm Type “Remote-ssh: Connect to Host…” on the Command Palette Select the identifier of the remote machine Select Linux Click “Continue” on the provided fingerprint Wait for docker to be installed and check with docker -version Data sources Add data \"azurerm_public_ip\" \"mtc-ip-data\" in the code Run terraform apply -refresh-only The data will be at the top of the state file Check the data with terraform state list Check the value of the data with terraform state show data.azurerm_public_ip.mtc-ip-data Outputs Add output \"public_ip_adrress\" in the code Check value with terraform state show data.azurerm_public_ip.mtc-ip-data Run terraform apply -refresh-only Run terraform output or terraform output public_ip_address Variables Add ${var.host_os} in the templatefile of the VM provisioner Create variables.tf with the host_osvariable and plan the deployment Add the attribute default to the variables.tf file Run terraform console and type var.host_os Comment the default attribute Create terraform.tfvars Run terraform console and type var.host_os Run terraform console -var=\"host_os=linux\" and type var.host_os Create osx.tfvars Run terraform console -var-file=\"osx.tfvars\" and type var.host_os Conditionals Syntax condition ? true_val : false_val Add the conditional in the VM provisioner Run terraform apply -auto-approve"
  }}
